// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: airports.sql

package db

import (
	"context"
)

const checkIfAirportsExist = `-- name: CheckIfAirportsExist :many
SELECT airport_code FROM airports WHERE airport_code = ANY($1)
`

func (q *Queries) CheckIfAirportsExist(ctx context.Context, db DBTX, airportCodes []string) ([]string, error) {
	rows, err := db.Query(ctx, checkIfAirportsExist, airportCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var airport_code string
		if err := rows.Scan(&airport_code); err != nil {
			return nil, err
		}
		items = append(items, airport_code)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAirportsWithFilters = `-- name: GetAirportsWithFilters :many
SELECT airport_code, airport_name, city, country FROM airports WHERE true 
    AND (city = $1 OR NOT $2::boolean)
    AND (country = $3 OR NOT $4::boolean)
`

type GetAirportsWithFiltersParams struct {
	City            string `json:"city"`
	FilterByCity    bool   `json:"filter_by_city"`
	Country         string `json:"country"`
	FilterByCountry bool   `json:"filter_by_country"`
}

func (q *Queries) GetAirportsWithFilters(ctx context.Context, db DBTX, arg GetAirportsWithFiltersParams) ([]Airport, error) {
	rows, err := db.Query(ctx, getAirportsWithFilters,
		arg.City,
		arg.FilterByCity,
		arg.Country,
		arg.FilterByCountry,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Airport
	for rows.Next() {
		var i Airport
		if err := rows.Scan(
			&i.AirportCode,
			&i.AirportName,
			&i.City,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableCitiesWithCountries = `-- name: GetAvailableCitiesWithCountries :many
SELECT DISTINCT city, country FROM airports where airport_code IN (
    SELECT arrival_airport FROM flights
    UNION ALL
    SELECT departure_airport FROM flights
)
`

type GetAvailableCitiesWithCountriesRow struct {
	City    string `json:"city"`
	Country string `json:"country"`
}

func (q *Queries) GetAvailableCitiesWithCountries(ctx context.Context, db DBTX) ([]GetAvailableCitiesWithCountriesRow, error) {
	rows, err := db.Query(ctx, getAvailableCitiesWithCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCitiesWithCountriesRow
	for rows.Next() {
		var i GetAvailableCitiesWithCountriesRow
		if err := rows.Scan(&i.City, &i.Country); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
