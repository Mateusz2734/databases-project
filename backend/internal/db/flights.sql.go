// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: flights.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFlight = `-- name: AddFlight :exec
INSERT INTO flights (departure_airport, arrival_airport, departure_datetime, arrival_datetime, airplane_id, price)
VALUES ($1, $2, $3, $4, $5::int, $6)
`

type AddFlightParams struct {
	DepartureAirport  string           `json:"departure_airport"`
	ArrivalAirport    string           `json:"arrival_airport"`
	DepartureDatetime pgtype.Timestamp `json:"departure_datetime"`
	ArrivalDatetime   pgtype.Timestamp `json:"arrival_datetime"`
	AirplaneID        int32            `json:"airplane_id"`
	Price             pgtype.Numeric   `json:"price"`
}

func (q *Queries) AddFlight(ctx context.Context, db DBTX, arg AddFlightParams) error {
	_, err := db.Exec(ctx, addFlight,
		arg.DepartureAirport,
		arg.ArrivalAirport,
		arg.DepartureDatetime,
		arg.ArrivalDatetime,
		arg.AirplaneID,
		arg.Price,
	)
	return err
}

const deleteFlight = `-- name: DeleteFlight :exec
DELETE FROM flights
WHERE flight_id = $1
`

func (q *Queries) DeleteFlight(ctx context.Context, db DBTX, flightID int32) error {
	_, err := db.Exec(ctx, deleteFlight, flightID)
	return err
}

const getFlightById = `-- name: GetFlightById :one
SELECT f.flight_id, f.departure_airport, f.arrival_airport, f.departure_datetime, f.arrival_datetime, f.airplane_id, f.price
FROM flights AS f
WHERE f.flight_id = $1
`

func (q *Queries) GetFlightById(ctx context.Context, db DBTX, flightID int32) (Flight, error) {
	row := db.QueryRow(ctx, getFlightById, flightID)
	var i Flight
	err := row.Scan(
		&i.FlightID,
		&i.DepartureAirport,
		&i.ArrivalAirport,
		&i.DepartureDatetime,
		&i.ArrivalDatetime,
		&i.AirplaneID,
		&i.Price,
	)
	return i, err
}

const getFlightsWithFilters = `-- name: GetFlightsWithFilters :many
SELECT f.flight_id, f.departure_airport, f.arrival_airport, f.departure_datetime, f.arrival_datetime, f.airplane_id, f.price
FROM flights AS f
JOIN airports AS a ON a.airport_code = f.departure_airport
    AND (a.airport_code = $1 OR NOT $2 :: boolean)
    AND (a.city = $3 OR NOT $4 :: boolean)
JOIN airports AS a2 ON a2.airport_code = f.arrival_airport
    AND (a2.airport_code = $5 OR NOT $6 :: boolean)
    AND (a2.city = $7 OR NOT $8 :: boolean)
WHERE true 
    AND (date_part('day', f.departure_datetime) = date_part('day', $9::timestamp) OR NOT $10::boolean)
    AND (date_part('day', f.arrival_datetime) = date_part('day', $11::timestamp) OR NOT $12::boolean)
    AND (f.price BETWEEN $13 AND $14 OR NOT $15::boolean)
    AND (f.departure_datetime > NOW())
`

type GetFlightsWithFiltersParams struct {
	FromAirport               string           `json:"from_airport"`
	FilterByFromAirport       bool             `json:"filter_by_from_airport"`
	FromCity                  string           `json:"from_city"`
	FilterByFromCity          bool             `json:"filter_by_from_city"`
	ToAirport                 string           `json:"to_airport"`
	FilterByToAirport         bool             `json:"filter_by_to_airport"`
	ToCity                    string           `json:"to_city"`
	FilterByToCity            bool             `json:"filter_by_to_city"`
	DepartureDatetime         pgtype.Timestamp `json:"departure_datetime"`
	FilterByDepartureDatetime bool             `json:"filter_by_departure_datetime"`
	ArrivalDatetime           pgtype.Timestamp `json:"arrival_datetime"`
	FilterByArrivalDatetime   bool             `json:"filter_by_arrival_datetime"`
	MinPrice                  pgtype.Numeric   `json:"min_price"`
	MaxPrice                  pgtype.Numeric   `json:"max_price"`
	FilterByPrice             bool             `json:"filter_by_price"`
}

func (q *Queries) GetFlightsWithFilters(ctx context.Context, db DBTX, arg GetFlightsWithFiltersParams) ([]Flight, error) {
	rows, err := db.Query(ctx, getFlightsWithFilters,
		arg.FromAirport,
		arg.FilterByFromAirport,
		arg.FromCity,
		arg.FilterByFromCity,
		arg.ToAirport,
		arg.FilterByToAirport,
		arg.ToCity,
		arg.FilterByToCity,
		arg.DepartureDatetime,
		arg.FilterByDepartureDatetime,
		arg.ArrivalDatetime,
		arg.FilterByArrivalDatetime,
		arg.MinPrice,
		arg.MaxPrice,
		arg.FilterByPrice,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Flight
	for rows.Next() {
		var i Flight
		if err := rows.Scan(
			&i.FlightID,
			&i.DepartureAirport,
			&i.ArrivalAirport,
			&i.DepartureDatetime,
			&i.ArrivalDatetime,
			&i.AirplaneID,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlight = `-- name: UpdateFlight :exec
UPDATE flights
SET departure_datetime = $1, arrival_datetime = $2, price = $3
WHERE flight_id = $4
`

type UpdateFlightParams struct {
	DepartureDatetime pgtype.Timestamp `json:"departure_datetime"`
	ArrivalDatetime   pgtype.Timestamp `json:"arrival_datetime"`
	Price             pgtype.Numeric   `json:"price"`
	FlightID          int32            `json:"flight_id"`
}

func (q *Queries) UpdateFlight(ctx context.Context, db DBTX, arg UpdateFlightParams) error {
	_, err := db.Exec(ctx, updateFlight,
		arg.DepartureDatetime,
		arg.ArrivalDatetime,
		arg.Price,
		arg.FlightID,
	)
	return err
}
